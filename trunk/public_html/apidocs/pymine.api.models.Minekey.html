<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>API docs for &ldquo;pymine.api.models.Minekey&rdquo;</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>
    <h1 class="class">Class p.a.m.Minekey:</h1>
    <p>
      <span id="part">Part of <a href="pymine.html">pymine</a>.<a href="pymine.api.html">api</a>.<a href="pymine.api.models.html">models</a></span>
      
      <a href="classIndex.html#pymine.api.models.Minekey">View In Hierarchy</a>
    </p>
    <div>
      
    </div>
    <div>A Minekey encodes all the data that a subscriber can use to retreive 
stuff from the user's mine, creating an opaque token that is hopefully 
unforgable.<table class="fieldTable"></table></div>
    
    
    <div id="splitTables">
      <table class="children sortable" id="id9">
  
  
  
  
  <tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#__init__">__init__</a></td>
    <td><span>Populates a Minekey with 5 items of information:</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#set_request">set_request</a></td>
    <td><span>Pokes a request into this and all descendent Minekeys, so that they can 
permalink()</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="pymine.api.models.Minekey.html#hashify">hashify</a></td>
    <td><span>return a b64-encoded hash of x with padding removed</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#generate_iv">generate_iv</a></td>
    <td><span>from an iid, generate a binary IV string of the appropriate length</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="pymine.api.models.Minekey.html#crypto_engine">crypto_engine</a></td>
    <td><span>return an intialised crypto engine - to be modified</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="pymine.api.models.Minekey.html#decrypt">decrypt</a></td>
    <td><span>decrypt x and return the result; will strip trailing whitespace 
padding</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="pymine.api.models.Minekey.html#encrypt">encrypt</a></td>
    <td><span>encrypt x and return the result prefixed by the IV; will pad plaintext 
with trailing whitespace as needed to satisfy the crypto algorithm</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#clone">clone</a></td>
    <td><span>clone this minekey for further futzing; if you do futz manually, 
remember to do minekey.validate()</span></td>
  </tr><tr class="classmethod">
    
    
    <td>Class Method</td>
    <td><a href="pymine.api.models.Minekey.html#parse">parse</a></td>
    <td><span>classmethod and pseudo-constructor; decrypt the b64-encoded</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#__str__">__str__</a></td>
    <td><span>calls validate() and then produces a string-representation of the</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#key">key</a></td>
    <td><span>takes the string representation of this minekey and produces the</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#permalink">permalink</a></td>
    <td><span>takes the result of self.key() and embeds / returns it in a</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#spawn_iid">spawn_iid</a></td>
    <td><span>from this minekey, spawn a new minekey object for the same</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#spawn_comment">spawn_comment</a></td>
    <td><span>from this minekey, spawn a new minekey object for comment 
submission.</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#rewrite_html">rewrite_html</a></td>
    <td><span>using the context of this minekey, rewrite the blob of HTML</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#get_relation">get_relation</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#get_item">get_item</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#validate">validate</a></td>
    <td><span>performs basic sanity checks on this minekey:</span></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="pymine.api.models.Minekey.html#validate_against">validate_against</a></td>
    <td><span>validate this minekey against a HTTP request (request),</span></td>
  </tr>
  
</table>
      
      
    </div>
    
    
    
    <div class="function">
        <a name="pymine.api.models.Minekey.__init__"></a>
        <a name="__init__"></a>
        <div class="functionHeader">
        
        def __init__(self, **kwargs):
        
      </div>
        <div class="functionBody">
          
          <div>Populates a Minekey with 5 items of information:</p>
<p>method=, rid=, rvsn=, iid=, depth=</p>
<p>method = 'get' or 'put'; these are somewhat analogous to GET and POST in
HTTP, but we override the latter for REST purposes because in the 
subscriber interface a Minekey can arrive by either GET or POST methods.  
Note that there is no 'delete' or anything exotic like that.</p>
<p>rid = id / primary key of the Relation for whom this minekey exists; 
this provides an identity for the incoming key, against which we can search
Item tags and so forth in order to generate a feed.</p>
<p>rvsn = relation.version for rid; this is a security check; if 
minekey.rvsn != Relation(id=rid).version then the request will fail; by 
this means you can invalidate all issued minekeys for a given relation 
without deleting it.</p>
<p>iid = id / primary key of the Item which this minekey references; if iid
== 0 then the item is the feed for the Relation.</p>
<p>depth = integer; this is a value in the range 0..3, although only values
1..3 are functional.  The 'depth' field tracks how far a subscriber can 
link-chase into a mine.</p>
<p>A feed URL will be iid=0 and depth=3</p>
<p>Item permalinks in the feed will have iid=N and depth=2</p>
<p>Links in HTML Items will be rewritten as iid=N and depth=1</p>
<p>Depth=0 is legal precisely so that it can be trapped in the mine 
auditing records, but it will yield a 404<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.set_request"></a>
        <a name="set_request"></a>
        <div class="functionHeader">
        
        def set_request(self, request):
        
      </div>
        <div class="functionBody">
          
          <div>Pokes a request into this and all descendent Minekeys, so that they can 
permalink()<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.hashify"></a>
        <a name="hashify"></a>
        <div class="functionHeader">
        @classmethod<br />
        def hashify(klass, x):
        
      </div>
        <div class="functionBody">
          
          <div>return a b64-encoded hash of x with padding removed<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.generate_iv"></a>
        <a name="generate_iv"></a>
        <div class="functionHeader">
        
        def generate_iv(self):
        
      </div>
        <div class="functionBody">
          
          <div>from an iid, generate a binary IV string of the appropriate length<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.crypto_engine"></a>
        <a name="crypto_engine"></a>
        <div class="functionHeader">
        @classmethod<br />
        def crypto_engine(klass, iv):
        
      </div>
        <div class="functionBody">
          
          <div>return an intialised crypto engine - to be modified<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.decrypt"></a>
        <a name="decrypt"></a>
        <div class="functionHeader">
        @classmethod<br />
        def decrypt(klass, x, iv):
        
      </div>
        <div class="functionBody">
          
          <div>decrypt x and return the result; will strip trailing whitespace 
padding<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.encrypt"></a>
        <a name="encrypt"></a>
        <div class="functionHeader">
        @classmethod<br />
        def encrypt(klass, x, iv):
        
      </div>
        <div class="functionBody">
          
          <div>encrypt x and return the result prefixed by the IV; will pad plaintext 
with trailing whitespace as needed to satisfy the crypto algorithm<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.clone"></a>
        <a name="clone"></a>
        <div class="functionHeader">
        
        def clone(self):
        
      </div>
        <div class="functionBody">
          
          <div>clone this minekey for further futzing; if you do futz manually, 
remember to do minekey.validate()<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.parse"></a>
        <a name="parse"></a>
        <div class="functionHeader">
        @classmethod<br />
        def parse(klass, external, **kwargs):
        
      </div>
        <div class="functionBody">
          
          <div>classmethod and pseudo-constructor; decrypt the b64-encoded minekey 
('external') and parse it, and then validate the results of parsing to 
permit use in data access.</p>
<p>throws exception on something being wrong.<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.__str__"></a>
        <a name="__str__"></a>
        <div class="functionHeader">
        
        def __str__(self):
        
      </div>
        <div class="functionBody">
          
          <div>calls validate() and then produces a string-representation of the 
minekey, including the hash-information and magic number, as well as the 
standard 5-tuple<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.key"></a>
        <a name="key"></a>
        <div class="functionHeader">
        
        def key(self):
        
      </div>
        <div class="functionBody">
          
          <div>takes the string representation of this minekey and produces the 
encrypted-and-base64-encoded minekey token, suitable for web 
consumption.<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.permalink"></a>
        <a name="permalink"></a>
        <div class="functionHeader">
        
        def permalink(self):
        
      </div>
        <div class="functionBody">
          
          <div>takes the result of self.key() and embeds / returns it in a permalink 
string for this mine; requires self.__request to be set or set_request() to
have been performed on this Minekey or one of its ancestors<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.spawn_iid"></a>
        <a name="spawn_iid"></a>
        <div class="functionHeader">
        
        def spawn_iid(self, iid):
        
      </div>
        <div class="functionBody">
          
          <div>from this minekey, spawn a new minekey object for the same rid/rvsn, but
for a different iid, decrementing the depth.<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.spawn_comment"></a>
        <a name="spawn_comment"></a>
        <div class="functionHeader">
        
        def spawn_comment(self):
        
      </div>
        <div class="functionBody">
          
          <div>from this minekey, spawn a new minekey object for comment 
submission.<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.rewrite_html"></a>
        <a name="rewrite_html"></a>
        <div class="functionHeader">
        
        def rewrite_html(self, html):
        
      </div>
        <div class="functionBody">
          
          <div>using the context of this minekey, rewrite the blob of HTML (argument) 
looking for case-insensitive strings of the form:</p>
<p>HREF=99 HREF='99' HREF=&quot;99&quot; SRC=99 SRC='99' 
SRC=&quot;99&quot;</p>
<p>...where 99 is an example iid, replacing the 99 with the results of 
self.spawn_iid(iid).permalink() - in other words a URL customised to 
retreive that item/iid with decremented depth.<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.get_relation"></a>
        <a name="get_relation"></a>
        <div class="functionHeader">
        
        def get_relation(self):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.get_item"></a>
        <a name="get_item"></a>
        <div class="functionHeader">
        
        def get_item(self):
        
      </div>
        <div class="functionBody">
          
          <div class="undocumented">Undocumented</div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.validate"></a>
        <a name="validate"></a>
        <div class="functionHeader">
        
        def validate(self):
        
      </div>
        <div class="functionBody">
          
          <div>performs basic sanity checks on this minekey:</p>
<p>method must be in ('get', 'put')</p>
<p>rid must not be &lt;= 0</p>
<p>rvsn must not be &lt;= 0</p>
<p>iid must not be &lt; 0 (remember: item 0 == feed)</p>
<p>depth must be in range 0..3 (remember: 0 valid but ineffectual)</p>
<p>Further validation in the specific context of an actual HTTP request is 
done by the validate_against() routine.<table class="fieldTable"></table></div>
        </div>
      </div><div class="function">
        <a name="pymine.api.models.Minekey.validate_against"></a>
        <a name="validate_against"></a>
        <div class="functionHeader">
        
        def validate_against(self, request, want_method):
        
      </div>
        <div class="functionBody">
          
          <div>validate this minekey against a HTTP request (request), manually 
specifying whether you want the minekey to be a 'get' or a 'put' 
(want_method)</p>
<p>this routine traps the 'depth==0' thing; this means attempts to walk 
over the mine via link-chasing get logged.</p>
<p>TODO: this routine performs relation timed-embargo checking</p>
<p>TODO: this routine performs global time-of-day access restriction 
checks</p>
<p>this routine performs checking of self.rvsn against 
Relation(id=rid).version and raises exception on mismatch</p>
<p>this routine performs relation source-IP-address checking</p>
<p>this routine checks that the item (if not iid=0) is either public or 
shared.</p>
<p>this routine performs &quot;not:relationname&quot; item tag checking<table class="fieldTable"></table></div>
        </div>
      </div>
    
    <address>
      <a href="index.html">API Documentation</a> for pymine, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at (date elided).
    </address>
  </body>
</html>